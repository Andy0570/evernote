## 静态库和动态库有什么异同？

### 静态库

链接时完整地拷贝至可执行文件中，被多次使用就有多份冗余拷贝。利用静态函数库编译成的**文件比较大**，因为整个函数库的所有数据都会被整合进目标代码中，他的优点就显而易见了，即编译后的执行程序**不需要外部的函数库支持**，因为所有使用的函数都已经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。

使用静态库的好处：

* 模块化，分工合作；
* 避免少量改动经常导致大量的重复编译连接；
* 也可以重用，注意不是共享使用；

### 动态库

链接时不复制，程序运行时由系统**动态加载**到内存，供程序调用，系统只加载一 次，多个程序共用，节省内存。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。

使用动态库的好处：

* 可以将最终可执行文件体积缩小；
* 多个应用程序共享内存中得同一份库文件，节省资源；
* 可以不重新编译连接可执行程序的前提下，更新动态库文件达到更新应用程序的目的。



静态库和动态库都是闭源库，只能拿来满足某个功能的使用，不会暴露内部具体的代码信 息，而从 GitHub 上下载的第三方库大多是开源库。

静态库和动态库都是由 `*.o`目标文件生成。



## 这两种库都有哪些文件格式？

静态库：`.a`和 `.framework` (windows:`.lib` , linux:`.a`) 

动态库：`.dylib`和`.framework`（系统提供给我们的 framework 都是动态库！）(windows:`.dll` , linux: `.so`) 

注意：两者都有 framework 的格式，但是当你创建一个framework 文件时，系统**默认是动态库的格式**，如果想做成静态库，需要在 **buildSetting** 中将 **Mach-O Type** 选项设置为 `Static Library` 就行了！



## `.a` 文件和 `.framework` 文件的区别？

* **`.a` 是一个纯二进制文件，不能直接拿来使用，需要配合头文件、资源文件一起使用**。 

  将静态库打包的时候，**只能打包代码资源**，图片、本地 json 文件和 xib 等资源文件无法打包进 去，使用 `.a` 静态库的时候需要三个组成部分：`.a` 文件 + 需要暴露的头文件 + 资源文件； 

* **`.framework` 中除了有二进制文件之外还有资源文件，可以拿来直接使用**。



## CocoaPods 通过 use_frameworks 来控制是否使用 Framework

1. 不使用 `use_frameworks!` -> static libraries 方式 -> 生成 `.a` 文件。

   在 Podfile 文件中，如不加 `use_frameworks!`，cocoapods 会生成相应的 `.a` 文件（静态链接库）。
   `Link Binary With Libraries: libPods-**.a` 包含了其他用 pod 导入有第三库的 `.a`文件。

2. `use_frameworks!` -> dynamic frameworks 方式 -> 生成 `.framework` 文件。

   使用了 `use_frameworks!`，cocoapods 会生成对应的 `frameworks` 文件（包含了头文件，二进制文件，资源文件等等）。
   `Link Binary With Libraries：Pods_xxx.framework` 包含了其它用 pod 导入的第三方框架的 `.framework` 文件。


