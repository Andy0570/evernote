## 5.1 详细设计的任务与原则

详细设计以概要设计阶段的工作为基础，但又不同于概要设计，主要表现为以下两个方面：

1. 在概要设计阶段，数据项和数据结构以比较抽象的方式描述，而详细设计阶段则应在此基础上给出**足够详细的描述**。

2. 详细设计要提供**关于算法的更多的细节**。例如：概要设计可以声明一个模块的作用是对一个表进行排序，详细设计则要确定使用哪种排序算法。在详细设计阶段为每个模块增加了足够的细节后，程序员才能够以相当直接的方式进行下一阶段的编程工作。



### 5.1.1 详细设计的任务



1. 为每个模块确定采用的**算法**，选择某种适当的工具表达算法的过程，写出模块的详细过程性描述。
2. 确定每一模块使用的**数据结构**。
3. 确定模块**接口的细节**。
4. 为每一个模块设计出一组**测试用例**。
5. 编写**详细设计说明书**。



### 5.1.2 详细设计的原则



1. 模块的逻辑描述正确可靠、清晰易读。
2. 选择适当的描述工具来对各模块的算法进行描述。
3. 采用结构化程序设计方法，改善控制结构，降低程序复杂度，提高程序的可读性、可测试性和可维护性。



## 5.2 结构化程序设计

### 5.2.1 结构化程序设计的概念

结构化程序设计（SP，Structured Programming）方法是由 Dijkstra 等人于1972年提出的，用于指导人们用良好的思维方式开发出正确又易于理解的程序。

![Edsger Wybe Dijkstra](https://upload-images.jianshu.io/upload_images/2648731-5ce90026f2dfe06d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

结构化程序设计是一种良好的程序设计技术和方法，它采用**自顶向下、逐步细化**的设计方法和单入口、单出口的控制结构。

Bohm 和 Jacopini 在 1966 年就证明了结构化程序定理：**任何程序结构都可以用顺序、选择和循环这3种基本结构及其组合来实现**。



### 5.2.2 结构化程序设计的原则

1. 使用语言中的顺序、选择、重复等有限的基本控制结构表示程序。
2. 选用的控制结构只准许有一个入口和一个出口。
3. 复杂结构应该用基本控制结构进行组合嵌套来实现。
4. 严格控制 GOTO 语句的使用。



示例，打印 A、B、C 3个数中最小值的程序。

![image](https://upload-images.jianshu.io/upload_images/2648731-3067b75ed1e6d3cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 5.2.3 结构化程序设计的优点

1. 自顶向下逐步求精的方法符合人类解决复杂问题的普遍规律，可以显著提高软件开发的成功率和生产率。
2. 先全局后局部、先整体后细节、先抽象后具体的逐步求精过程开发出的程序有清晰的层次结构。

3. 使用单入口单出口的控制结构而不使用GOTO语句，使得程序的静态结构和它的动态执行情况比较一致。
4. 控制结构有确定的逻辑模式，编写程序代码只限于使用很少几种直截了当的方式。
5. 程序清晰和模块化使得在修改和重新设计一个软件时可以重用的代码量最大。
6. 程序的逻辑结构清晰，有利于程序正确性验证。



## 5.3 过程设计工具

描述程序模块处理过程的工具称为过程设计工具，主要有**图形**、**表格**和**语言**三大类。

![过程设计工具](https://upload-images.jianshu.io/upload_images/2648731-381c1fb5c81f8a0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 5.3.1 程序流程图

**程序流程图**（Program Flow Chart）又称为程序框图，是一种描述程序的控制结构流程和指令执行情况的有向图。它是历史最悠久，使用最广泛的过程描述方法。



#### 程序流程图中的符号

![程序流程图中的符号](https://upload-images.jianshu.io/upload_images/2648731-4edb29c4f1cdb659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1. 顺序型：几个连续的加工按先后顺序排列。
2. 选择型：由某个判断式的取值决定选择两个加工中的一个。
3. 当型循环：当循环控制条件成立时，重复执行特定的加工。
4. 直到型循环：重复执行特定的加工，直到循环控制条件成立时止。
5. 多分支选择型：列出多种加工情况，根据控制变量的取值，选择执行其一。

![程序流程图](https://upload-images.jianshu.io/upload_images/2648731-2edbb67b8e2fcaf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 程序流程图示例

![程序流程图示例](https://upload-images.jianshu.io/upload_images/2648731-003622cd380fde42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





### 5.3.2 N-S 图

* Nassi 和 Shneiderman 出于要有一种不允许违背结构化程序设计精神的图形工具考虑，提出了盒图，又称为N-S 图。
* 盒图没有箭头，因此不允许随意转移控制。使用盒图作为详细设计的工具，可以使程序员逐步养成用结构化的方式思考问题和解决问题的习惯。

![盒图](https://upload-images.jianshu.io/upload_images/2648731-a6927d5d0744b0bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 盒图示例

![盒图示例](https://upload-images.jianshu.io/upload_images/2648731-37ab27f3db137e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 5.3.3 PAD 图

* 问题分析图（PAD，Problem Analysis Diagram），1973 年由日本日立公司发明，已得到一定程度的应用。

* 它用二维树形结构图来表示程序的控制流，将这种图翻译成程序代码比较容易。

![PAD图](https://upload-images.jianshu.io/upload_images/2648731-2bdab85c817667a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### PAD 图示例

![PAD图示例](https://upload-images.jianshu.io/upload_images/2648731-40e3de480b6138fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



**PAD 图**表达的软件过程呈树形结构，它即克服了传统的**流程图**不能清晰表现程序结构的缺点，又不像 **N-S 图**那样受到把全部程序约束在一个方框内的限制，这就是它的优势所在。





### 5.3.4 判定表

在数据处理中，有时数据流的加工需要依赖于多个逻辑条件的取值，就是说完成这一加工的一组动作是由一组条件取值的组合而引发的。这时使用判定表来描述比较合适。

判定表通常由四部分组成：左上部分列出所有的**条件**，左下部分为所有可能的**操作**，右上部分表示各种**条件组合**的一个矩阵，右下部分是对应**每种条件组合应有的操作**。



#### 例，商店业务处理系统中“检查发货单”判定表

![判定表示例](https://upload-images.jianshu.io/upload_images/2648731-bb857a25d51aa6bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 5.3.5 判定树

**判定树**是判定表的变种，它能清晰地表达复杂的条件组合与所对应的操作之间的关系。判定树的优点在于它无须任何说明，一眼就能看出其含义，易于理解和使用。



#### 示例：商店业务处理系统中“检查发货单”判定树：

![判定树示例](https://upload-images.jianshu.io/upload_images/2648731-08effd11559495fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 5.3.6 PDL 语言

**PDL** 是一种用于描述功能模块的算法设计和加工细节语言，称为**过程设计语言**。它是一种伪代码**(Pseudo Code)**。

PDL——关键字+自然语言



PDL 具有严格的关键字外部语法，用于定义控制结构和数据结构；另一方面，PDL 表示实际操作和条件的内部语法通常又是灵活自由的，以便可以适应各种工程项目的需要。因此，一般说来 PDL 是一种“混杂”语言，它使用一种语言（通常是某种自然语言）的词汇，同时却使用另一种语言（某种结构化的程序设计语言）的语法。

#### 选择型结构

```
 IF <条件>
   THEN  <程序块/伪代码语句组>； 
   ELSE   <程序块/伪代码语句组>；
 ENDIF
```

#### 重复型结构

```
DO WHILE <条件描述>
    <程序块/伪代码语句组>；    
 ENDDO
```

```
REPEAT UNTIL <条件描述>
    <程序块/伪代码语句组>；    
 ENDREP
```

#### 步长重复型结构

```
 DO FOR <下标=下标表，表达式>
      <程序块/伪代码语句组>；         
 ENDFOR
```

#### 多分支选择结构

```
 CASE OF <case 变量名>；
    WHEN < case 条件1> SELECT <程序块/伪代码语句组>；
    WHEN < case 条件2> SELECT <程序块/伪代码语句组>；
      …  …
    DEFAULT:  缺省或错误case:  <程序块/伪代码语句组>；
 ENDCASE
```



#### 示例：商店业务处理系统中“检查发货单”的伪代码

```
if 发货单金额超过$500 then
      if 欠款超过了60天 then
              在偿还欠款前不予批准
      else （欠款未超期）
              发批准书，发货单
     endif 
else （发货单金额未超过$500）
      if 欠款超过60天 then
              发批准书，发货单及赊欠报告
      else （欠款未超期）
              发批准书，发货单
   endif
endif 
```

```
IF the invoice exceeds $500 THEN
	IF the account has any invoice more than 60 days overdue THEN
		the confirmation pending resolution of the debt
	   ELSE 
		issue confirmation and invoice
	ENDIF
ELSE
	IF the account has any invoice more than 60 days overdue THEN
      issue confirmation,invoice and write message on credit action report
	ELSE
	   issue confirmation and invoice 
   ENDIF
 ENDIF
```



#### PDL 的特点

* 提供全部**结构化控制结构**和**模块特征**。能对PDL正文进行结构分割，使之变得易于理解。
* 有**数据说明机制**，包括简单的(如变量和数组)与复杂的(如链表和层次结构)数据结构。
* 有**子程序定义与调用机制**，用以表达各种方式的接口说明。
* 为了区别关键字，规定关键字一律大写，其它单词一律小写。或者规定关键字加下划线，或者规定它们为黑体字。
* 内语法使用**自然语言**来描述处理特性。内语法比较灵活，只要写清楚就可以，以利于人们可把主要精力放在描述算法的逻辑上。



### 加工逻辑描述工具的选择

1. 对于不太复杂的判断逻辑，使用判定树比较好；
2. 对于复杂的判断逻辑，使用判定表比较好；
3. 若一个处理逻辑既包含了一般的顺序执行动作，又包含了判断或循环逻辑，则使用 PDL 语言比较好。





## 5.4 用户界面设计

用户界面是用户和计算机交互的重要途径，用户可以通过屏幕窗口与计算机进行对话，向计算机输入有关数据，控制计算机的处理过程并将处理结果反馈给用户。因此，界面设计必须从用户操作方便的角度来考虑，与用户共同协商界面的内容和形式。



### 5.4.1 用户界面设计的“黄金规则”

Theo Mandel 在 1997 年提出了界面设计的 3 条“黄金规则”：

1. 界面应置于用户控制之下。
2. 减少用户的记忆负担。
3. 保持界面风格的一致性。

这些规则实际上构成了指导用户界面设计活动的基本原则。



### 5.4.2 用户界面设计过程

用户界面设计是一个不断的迭代过程，可以用类似软件生命周期中的**螺旋模型**来表示。

用户界面设计过程包括 4 个活动过程：

1. 用户、任务和环境分析。
2. 界面设计。
3. 界面构造（实现）。
4. 界面确认。

![界面设计过程](https://upload-images.jianshu.io/upload_images/2648731-7250f0faa88e742d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 5.4.3 用户界面设计的主要形式



#### 5.4.3.1 菜单式

通过屏幕显示可选择的功能代码，由用户根据需要进行选择，可将菜单设计成层次结构，通过层层调用可以引导用户使用系统的每一个功能。随着软件技术的发展，菜单设计也更加趋于美观、方便和实用。目前，系统设计中常用的菜单设计方法主要如下：

（1）一般菜单：在屏幕上显示出各个选项，每个选项指定一个代码（数字或字母），然后根据用户输入的代码或单击鼠标，即可决定何种后续操作。

![表操作菜单](https://upload-images.jianshu.io/upload_images/2648731-a2a0c9507ad48aff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

（2）下拉式菜单：它是一种二级菜单，第一级是选择栏，第二级是选择项，选择栏横排在屏幕的上方，用户可以利用光标控制键选定当前菜单栏，在当前菜单栏下立即显示出该栏的各项功能，以供用户进行选择。

![下拉式菜单](https://upload-images.jianshu.io/upload_images/2648731-ddbc8b02f282171c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



（3）快捷菜单：选中对象后单击鼠标右键所出现的弹出式菜单，将鼠标移到所需的功能项目上，然后单击左键即执行相应的操作。

![快捷菜单](https://upload-images.jianshu.io/upload_images/2648731-e0ec52b8181bdb8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





#### 5.4.3.2 填表式

填表式一般用于通过终端向软件系统输入数据，软件系统将要输入的项目显示在屏幕上，然后由用户逐项填入有关数据。填表式界面设计常用于软件系统的输出。

在查询软件系统中的数据时，可以将数据的名称按一定的方式排列在屏幕上，然后由计算机将数据的内容自动填写在相应的位置上。由于这种方法简便易读，并且不容易出错，所以它是通过屏幕进行输入输出的主要形式。

![126邮箱注册表](https://upload-images.jianshu.io/upload_images/2648731-d026bb254c18fca9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 5.4.3.3 选择问答式

选择问答式。当软件系统运行到某一阶段时，可以通过屏幕向用户提问，软件系统根据用户选择的结果决定下一步执行什么操作。这种方法通常可以用在提示操作人员确认输入数据的正确性或者询问用户是否继续某项处理等方面。例如，当用户进行某种操作后，可通过屏幕询问“是否继续（Y/N）”，计算机根据用户的回答来决定是继续进行还是退出。

![选择问答式](https://upload-images.jianshu.io/upload_images/2648731-e626e75654440baa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#### 5.4.3.4 表单式

用户界面是一个表单（工作窗口），表单上有各种控件，如标签、文本框、组合框、命令按钮等。

![表单式](https://upload-images.jianshu.io/upload_images/2648731-dcf4ca97f6b6cfee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



### 5.4.4 界面设计应考虑的因素

**在选用界面形式的时侯，应当考虑每种类型的优点和限制：**

* **使用的难易程度**：对于没有经验的用户，该界面使用的难度有多大。
* **学习的难易程度**：学习该界面的命令和功能的难度有多大
* **操作速度**：在完成一个指定操作时，该界面在操作步骤、击键和反应时间等方面效率有多高。
* **复杂程度**：该界面提供了什么功能、能否用新的方式组合这些功能以增强界面的功能。
* **开发的难易程度**：该界面设计是否有难度、开发工作量有多大。



### 5.4.5 用户界面设计分析

界面设计分析应与软件系统的需求分析同步进行。它主要包括：

* 用户特性分析
  * 外行型
  * 初学型
  * 熟练型
  * 专家型
* 用户工作分析
* 记录有关系统的概念和术语
* 确定界面类型



### 5.4.6 用户界面的质量要求

* **可使用性**：使用简单；保持界面术语标准化和一致性；拥有Help帮助功能； 具有快速的系统响应和低的系统成本；具有容错能力。
* **灵活性**：用户可以根据需要制定和修改界面方式；能够按照用户需要，提供不同详细程度的系统响应信息。
* 复杂性和可靠性：
  * 用户界面的规模和组织的复杂程度就是界面的复杂性。在完成预定功能的前提下，用户界面越简单越好。
  * 用户界面的可靠性是指无故障使用的间隔时间。用户界面应能保证用户正确、可靠地使用系统，保证有关程序和数据的安全性。





## 5.5 数据库设计

* 数据库设计是建立一个应用系统重要的任务之一，数据库设计应该和应用系统设计相结合，整个软件系统的设计过程要把数据（结构）设计和行为（处理）设计密切结合起来。
* 数据库设计过程一般包括6个阶段：数据需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库运行与维护。



### 5.5.1 数据需求分析

首先必须**准确了解用户数据需求**。需求分析是整个软件设计的基础，也是数据库设计的基础。需求分析做得是否充分、准确，决定了在其基础上构建的数据库的质量与效率。

### 5.5.2 概念结构设计

将需求分析得到的用户需求进行综合、归纳与抽象，形成信息结构即为概念模型，这一过程就是概念结构设计。

描述概念模型的有力工具是 ER 图，其反映的是数据库中的实体概念、属性及联系。

1. 设计概念结构的要求：
   * 能真实、充分地反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求。
   * 易于理解。
   * 易于修改。
   * 易于向关系型、网状型、层次型等各种数据模型转换。

2. 概念结构设计的方法：
   * 自顶向下法。即首先定义全局概念结构的框架，然后逐渐向下逐步细化。
   * 自底向上法。即首先定义各局部的概念结构，然后将它们集合起来，得到全局概念结构。
   * 逐步扩张法。首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至形成总体概念结构。
   * 混合策略。即将自顶向下和自底向上相结合，用自顶向下设计一个全局概念结构的框架，以它为骨架集成自底向上设计的各局部概念结构。



### 5.5.3 逻辑结构设计

概念结构是独立于任何一种数据模型的信息结构。

逻辑结构设计的任务就是把由概念结构设计好的ER图转换为与选用的DBMS产品支持的数据模型相符合的逻辑结构。这里的转换就是把表示概念结构的ER图转换成关系模型的逻辑结构。

例如，概念结构中的实体之间的关系有一一关系、一多关系、多一关系、多多关系。而DBMS支持的逻辑结构中的关系有一多关系和多一关系，则可以将一一关系看作是一多关系或多一关系的特例来处理。将多多关系分解或合并为一多关系或多一关系，以适应DBMS的要求。



### 5.5.4 物理结构设计

物理设计的目的是根据具体的DBMS特征，确定数据库的物理结构（**存储结构与存取方式**）。

关系数据库的物理设计任务包括三个方面：

* 确定所有数据库文件的名称及其所含字段的名称、类型和宽度；
* 确定各数据库文件需要建立的索引及在什么字段上建立索引；
* 对物理结构进行优化和评价，重点是物理存取的时间和空间效率。



### 5.5.5 数据库实施

完成数据库的物理设计后，设计人员就要用DBMS提供的数据定义语言（如SQL Server，Oracle，VF，Access等）和其他程序设计语言（如C，C++，JAVA，VB等）将数据库的逻辑设计和物理设计结果描述出来，成为DBMS可以接受的数据库和源代码，这就是数据库的实施。

数据库的实施工作有：

1. 建立数据库结构。
2. 数据载入。
3. 应用程序的编写和调试。
4. 数据库系统的试运行。



## 5.6 接口设计



### 5.6.1 软件接口设计的依据

* **接口设计**的主要依据是**数据流图中的系统边界**。
* 系统边界将数据流图中的处理划分为：
  * **手工处理部分**，在系统边界之外的是手工处理部分
  * **系统处理部分**，系统边界之内的是系统处理部分
* 数据可以在系统内部、系统外部或穿越系统流动。穿过系统边界的数据流代表了系统的输入和输出。
* **系统的接口**（包括用户界面及与其他系统的接口）是由穿越系统边界的数据流定义的。在最终的系统中，数据流将成为用户界面中的表单、报表或与其他系统进行交互的文件或消息。



### 5.6.2 软件接口的类型

软件接口主要包括 3 个方面：

* **系统内模块之间的接口（内部接口）**，内部接口设计描述模块间数据传递等。
* **目标系统与其他软硬件之间的接口（外部接口）**，外部接口设计描述软硬件输入输出、网络传输协议等；
* **系统与用户之间的接口（人机交互界面）**，用户接口设计描述用户操作和反馈结果等；



### 5.6.3 应用程序编程接口

应用程序编程接口，简称API（Application Programming Interface），就是软件系统不同组成部分衔接的约定。 在程序设计的实践中，编程接口的设计首先要使系统的职责得到合理划分。良好的接口设计可以降低系统各部分的相互依赖，提高组成单元的内聚性，降低组成单元间的耦合程度，从而提高系统的维护性和扩展性。



API 的表现形式是源代码。API 的应用大大促进了计算机产业的进步，同时 API 几乎决定着日常运算的各个方面。

大多数程序员秉承为软件用户设计优秀的用户界面思想，这一点早已深入人心。另一方面，如何实现合理的软件API却只为少数人所重视。历史证明，所有在应用上获得成功的软件或者Web应用无一不是首先在API的设计上满足了用户的需求！



**API 的主要目的是提供应用程序与开发人员访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。**提供API所定义功能的软件称作API的实现。

一组 API 通常是一套软件开发工具包（SDK）的一部分。API 有许多不同设计，用于快速执行的接口通常包括函数、常量、变量与数据结构。典型情况下，API由一个或多个提供某种特殊功能的动态连接文件DLL组成。







## 5.7 详细设计说明书

典型的详细设计说明书的基本模型：

1. 引言
1.1 编写的目的
    说明编写该详细设计说明书的目的，并指明其预期的读者。
1.2 背景
    说明该项目的相关信息，包括项目的名称、提出者、开发者以及最终用户等。
1.3 定义
   列出文档中用到的专业术语的定义以及外文缩写词的全称。
1.4 参考资料
   列出相关参考资料的标题、作者、文件编号、发表日期、出版单位，并说明其来源。这些相关的参考资料包括项目的计划任务书、合同或上级机关批文、本项目的其他相关文档及操作手册、本文档所引用资料的出处、以及软件开发标准。
2. 系统的结构
   用各种描述工具描述系统中每一个模块及子程序的名称、标识符、功能及其它们之间的层次结构与调用关系
3. 程序1（标志符）设计说明
   3.1 程序描述
     简要描述该程序的设计目的及其该程序的特点。
   3.2 功能
     说明该程序应具备的功能。
   3.3 性能
   说明对该程序各个方面的性能要求。
   3.4 输入项
   列出每个输入项的特性。
   3.5 输出项
    列出每个输出项的特性。
   3.6 算法
   说明该程序所采用的算法。
   3.7 流程逻辑
    以图表的形式描述程序的流程逻辑。如采用流程图、N-S图、PAD图和判定表等来进行描述。
   3.8 接口
    说明该程序与相关联模块之间的关系，包括它们之间的数据传送、相互间的调用关系等。
   3.9 存储分配
    说明与该程序相关的存储文件的存储方式及其分配情况。
   3.10 注释设计
    对模块及内部小模块将要实现什么功能和彼此的关系加以注释，还有对其中用到的变量的属性功能也加以注释。
   3.11 限制条件 
    说明该程序在运行中所受到的限制条件。
   3.12 测试计划 
   说明将要对该程序进行测试的计划。
   3.13 尚未解决的问题 
   列出在该程序的设计中尚未解决而设计者认为在完成该软件之前必须解决的问题。 
4. 程序2（标志符）设计说明
     与程序1设计说明类似，对程序2—程序n进行描述。
     ……
