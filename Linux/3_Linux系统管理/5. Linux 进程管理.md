[TOC]

* Linux 内核通过使用进程来管理多任务，进程表示正在运行的程序。
* 进程标识——PID，父进程标识——PPID。
* 群组标识——GID，创建者所属组的 ID 号。
* 用户可以设置进程的“**谦让度**”，**高谦让度意味着低优先级**。

## 进程工作原理

* 当系统启动后，内核先把它自己的程序初始化为进程，然后运行一个叫做 **init** 的程序，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。 
* 其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户接口。
* 一个程序可以发动另一个程序，这个事实在进程方案中，表述为一个父进程创建了一个子进程。
* 内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是 1。内核也对分配给每个进程的内存进行跟踪。像文件一样，进程也有所有者和用户 ID，有效用户 ID，等等。

## 进程管理命令

### `ps` 报告当前进程快照
虽然 `ps` 命令能够展示许多计算机运行状态的信息，但是它只是提供 `ps` 命令执行时刻的机器状态的快照。

Linux 系统中使用的 GNU `ps` 命令支持3种不同类型的命令行参数：
* Unix 风格的参数，前面加单破折线；
* BSD 风格的参数，前面不加破折线；
* GNU 风格的长参数，前面加双破折线；

|BSD 风格的 ps 命令参数 | 描述 |
| ------------------ | ---- |
|T |显示跟当前终端关联的所有进程|
|a |显示跟任意终端关联的所有进程||
|g |显示所有的进程，包括控制进程|
|r |仅显示运行中的进程|
|x |显示所有的进程，甚至包括未分配任何终端的进程|
|U userlist |显示归 userlist 列表中某用户ID所有的进程|
|p pidlist |显示PID在 pidlist 列表中的进程|
|t ttylist |显示所关联的终端在 ttylist 列表中的进程|
|O format |除了默认输出的列之外，还输出由 format 指定的列|
|X |按过去的Linux i386寄存器格式显示|
|Z |将安全信息添加到输出中|
|j |显示任务信息|
|l |采用长模式|
|o format|仅显示由 format 指定的列|
|s|采用信号格式显示|
|u|采用基于用户的格式显示|
|v|采用虚拟内存格式显示|
|N namelist|定义在WCHAN 列中使用的值|
|O order|定义显示信息列的顺序|
|S|将数值信息从子进程加到父进程上，比如CPU和内存的使用情况|
|c|显示真实的命令名称（用以启动进程的程序名称）|
|e|显示命令使用的环境变量|
|f|用分层格式来显示进程，表明哪些进程启动了哪些进程|
|h|不显示头信息|
|k sort|指定用以将输出排序的列|
|n|和WCHAN 信息一起显示出来，用数值来表示用户ID和组ID|
|w|为较宽屏幕显示宽输出|
|H|将线程按进程来显示|
|m|在进程后显示线程|
|L|列出所有格式指定符|
|V|显示ps 命令的版本号|



```shell
# 1⃣️ 默认情况下，ps 命令只会显示运行在当前控制台下的属于当前用户的进程。
$ ps
  PID TTY          TIME CMD
 6650 pts/0    00:00:00 bash
 6995 pts/0    00:00:00 ps
 
# 2⃣️ 展示所有进程
$ ps x
  PID TTY      STAT   TIME COMMAND
    1 ?        Ss     0:28 /lib/systemd/systemd --system --deserialize 20
    2 ?        S      0:00 [kthreadd]
    3 ?        S      0:13 [ksoftirqd/0]
    5 ?        S<     0:00 [kworker/0:0H]
  ...
```
* TTY 是 "Teletype" 的简写，是指进程的控制终端，在 TTY 一栏中出现的 "?" ，表示没有控制终端。
* TIME 字段表示进程所消耗的 CPU 时间数量。
* STAT ，进程的双字符状态码，是 "state" 的简写，表示进程当前状态。

| 进程状态（STAT） | 含义 |
| --- | --- |
| R | 运行。进程正在运行或准备运行。 |
| S | 正在睡眠。进程没有运行，而是，正在等待一个事件，比如说，一个按键或者网络数据包。 |
| D | 不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。 |
| T | 已停止. 已经指示进程停止运行。 |
| Z | 死进程或 “僵尸” 进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。（父进程没有把子进程从进程表中删除） |
| < | 高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice），因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。 |
| N | 低优先级进程。一个低优先级进程（一个 “好” 进程）只有当其它高优先级进程执行之后，才会得到处理器时间。 |

```shell
# 3⃣️ 显示进程详细信息（ 以 BSD 风格输出）
$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0 119840  6072 ?        Ss    2018   0:28 /lib/systemd/systemd --system --deserialize 20
root         2  0.0  0.0      0     0 ?        S     2018   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S     2018   0:13 [ksoftirqd/0]
root         5  0.0  0.0      0     0 ?        S<    2018   0:00 [kworker/0:0H]
...

# 4⃣️ 在进程列表中搜索 init 进程
$ ps aux | grep init
root      9948  0.0  0.0  14192   924 pts/0    S+   11:08   0:00 grep --color=auto init

# 显示 node.js 进程
$ ps aux | grep node

# 5⃣️ 可以显示进程父进程ID（PPID）和谦让度（NI）
$ ps lax
F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
4     0     1     0  20   0 119840  6072 ep_pol Ss   ?          0:28 /lib/systemd/systemd --system --deserialize 20
1     0     2     0  20   0      0     0 kthrea S    ?          0:00 [kthreadd]
1     0     3     2  20   0      0     0 smpboo S    ?          0:13 [ksoftirqd/0]
1     0     5     2   0 -20      0     0 worker S<   ?          0:00 [kworker/0:0H]
```



BSD 风格的 ps 命令列表：
| 标题 | 含义 |
| --- | --- |
| USER | 用户ID，进程的所有者。 |
| %CPU | 以百分比表示的 CPU 使用率。 |
| %MEM | 以百分比表示的内存使用率。 |
| VSZ | 进程在内存中的大小，以千字节（KB）为单位。 |
| RSS | 进程在未换出时占用的物理内存，以千字节为单位。 |
| START | 进程运行的起始时间。若超过 24 小时，则用天表示。 |


### `top` 动态查看进程
* `top` 程序连续显示系统进程更新的信息（默认情况下，每 5s 更新一次）。
* `top` 显示结果由两部分组成：最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。


```shell
$ top
top - 18:01:00 up 88 days,  1:19,  1 user,  load average: 0.00, 0.00, 0.00
Tasks: 156 total,   1 running, 155 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.1 sy,  0.0 ni, 99.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8174524 total,  1836288 free,  2201156 used,  4137080 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  5553516 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 2087 root      20   0 2842252 1.493g  29056 S   0.3 19.2   5261:51 mongod
    1 root      20   0  119840   6072   4088 S   0.0  0.1   0:28.09 systemd
 ...
 
###########################################
进程列表监控信息字段含义：

PID — 进程 id
USER — 进程所有者
PR — 进程优先级
NI — nice 值。进程的谦让度。负值表示高优先级，正值表示低优先级
VIRT — 进程使用的虚拟内存总量，单位 kb。VIRT=SWAP+RES
RES — 进程使用的、未被换出的物理内存总量，单位 kb。RES=CODE+DATA
SHR — 共享内存大小，单位 kb
S — 进程状态。D = 可中断的睡眠状态，R = 运行状态，S = 睡眠状态，T = 跟踪/停止状态，Z = 僵尸进程
%CPU — 上次更新到现在的 CPU 时间占用百分比
%MEM — 进程使用的物理内存百分比
TIME+ — 进程使用的 CPU 时间总计，单位 1/100 秒
COMMAND — 进程名称（命令名 / 命令行）
###########################################
```

其中系统概要包含许多有用信息。下表是对系统概要的说明：

| 行号 | 字段 | 含义 |
| --- | --- | --- |
| 1 | top | 程序名。 |
|  | 18:01:00 | 当前系统时间。 |
|  | up 88 days,  1:19 | 这是正常运行时间。它是计算机从上次启动到现在所运行的时间。在这个例子里，系统已经运行了88天1小时19分钟。 |
|  | 1 user | 有一个用户登录系统。 |
|  | load average: | 加载平均值（系统负载），等待运行的进程数目，也就是说，处于运行状态的进程个数，这些进程共享 CPU。展示了三个数值，每个数值对应不同的时间周期。第一个是最后 60 秒的平均值， 下一个是前 5 分钟的平均值，最后一个是前 15 分钟的平均值。若平均值低于 1.0，则指示计算机工作不忙碌。 |
| 2 | Tasks | 总结了进程数目和各种进程状态。 |
| 3 | %Cpu(s) | 这一行描述了 CPU 正在执行的进程的特性。 |
|  | 0.0 us | 用户空间占用 CPU 的百分比。 |
|  | 0.1 sy | 0.1% 的 CPU 时间被用于系统（内核）进程。 |
|  | 0.0 ni | 改变过优先级的进程占用 CPU 的百分比 |
|  | 99.9 id | 99.9% 的 CPU 时间是空闲的。 |
|  | 0.0 wa | 0.0% 的 CPU 时间来等待 I/O。 |
|  | hi | 硬中断（Hardware IRQ）占用 CPU 的百分比 |
|  | si | 软中断（Software Interrupts）占用 CPU 的百分比 |
| 4 | Mem | 展示物理内存的使用情况。 |
| 5 | Swap | 展示交换分区（虚拟内存）的使用情况。 |
`top` 程序接受一系列从键盘输入的命令。两个最有趣的命令是 h 和 q。
* h，显示程序的帮助屏幕。
* q，退出 `top` 程序。

### 进程管理快捷键
使用此方法，许多（但不是全部）命令行程序可以被中断。

| 快捷键 | 含义 |
| --- | --- |
| Ctrl+C | 中断一个进程 |
| Ctrl+Z | 停止一个进程 |
| Ctrl+D | exit，退出终端 |
| Ctrl+L | clear，清屏 |
| shift+. |  退出无响应终端 |

### `jobs` 查看作业
`jobs` 命令可以查看分配给 shell 的作业。

格式：`jobs`

jobs 命令参数 | 描述
--- | ---- 
-l | 列出进程的PID以及作业号
-n | 只列出上次shell发出的通知后改变了状态的作业
-p | 只列出作业的PID
-r | 只列出运行中的作业
-s | 只列出已停止的作业

* 带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。
* 当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加号的作业和一个带减号的作业，不管shell中有多少个正在运行的作业。

### `bg` 重启停止的作业
命令格式：`bg 作业号`

启动一个程序，让它立即在后台运行，只要在程序命令之后，加上"&"字符：`command &`

### `fg` 以前台模式重启作业
命令格式：`fg %工作序号`

### `kill` 给一个进程发送信号

命令格式：`kill [-signal] PID`。

`kill` 命令可通过进程 ID（PID）给进程发信号。默认情况下，`kill` 命令会向命令行中列出的全部PID发送一个 TERM（终止）信号。

TERM 信号告诉进程可能的话就停止运行。不过，如果有不服管教的进程，那它通常会忽略这个请求。

| 常用信号编号 | 名字 | 含义 |
| --- | --- | --- |
| 1 | HUP | 挂起。许多守护进程也使用这个信号，来重新初始化。这意味着，当发送这个信号到一个守护进程后，这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。 |
| 2 | INT | 中断。实现和 Ctrl+C 一样的功能，由终端发送。通常，它会终止一个程序。 |
| 9 | KILL | 杀死。这个信号很特别。鉴于进程可能会选择不同的方式，来处理发送给它的信号，其中也包含忽略信号，这样呢，从不发送 Kill 信号到目标进程。而是内核立即终止这个进程。当一个进程以这种方式终止的时候，它没有机会去做些 “清理” 工作，或者是保存劳动成果。 因为这个原因，把 KILL 信号看作杀手锏，当其它终止信号失败后，再使用它。 |
| 15 | TERM | 终止。这是 kill 命令发送的默认信号。如果程序仍然 “活着”，可以接受信号，那么这个信号终止。 |
| 18 | CONT | 继续。在停止一段时间后，进程恢复运行。 |
| 19 | STOP | 停止。这个信号导致进程停止运行，而没有终止。像 KILL 信号，它不被发送到目标进程，因此它不能被忽略。 |

```shell
# 查看完整的信号列表
$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX

# KILL 可以在内核级别“杀死”一个进程
$ sudo kill -KILL pid
$ sudo kill -SIGKILL pid
$ sudo kill -9 pid
```

### `killall` 杀死指定名字的进程
通过 `killall` 命令，可以给匹配特定程序或用户名的多个进程发送信号。该命令可以直接使用进程的名字而不是进程标识号。
格式：`killall [-u user] [-signal] name`

```shell
$ killall -HUP inetd

# killall 命令也支持通配符，如，结束所有以 http 开头的进程：
$ killall http*
```

### `nice` 启动程序时设置其谦让度

* 高谦让度意味着低优先级。
* 谦让度的值应该在 -20（最高优先级）～ +19（最低优先级） 之间浮动。
* 默认情况下，bash shell 以优先级0来启动所有进程。
* 进程的属主可以提高进程的谦让度（降低优先级），但不能降低其谦让度（提高优先级）。
* root 用户可以任意设置进程的优先级。

```shell
$ nice -n 2 bc          ## 设置 bc 以谦让度增量 2 启动
$ sudo nice -n -3 bc    ## 使用 root 权限才能降低谦让度
$ nice bc               ## 不带 -n 参数的 nice 命令会将程序的谦让度增量设置为 10

$ nice                  ## 查看默认谦让度值
```

### `renice` 进程运行时调整其谦让度

* `nice` 命令调整**相对谦让度**值，`renice` 命令调整**绝对谦让度**值。

```shell
$ ps lax               ## 获得进程的 PID
$ renice +12 -p pid    ## -p选项指定进程的 PID
```

### 更多和进程相关的命令

| 命令名 | 命令描述 |
| --- | --- |
| pstree | 输出一个树型结构的进程列表，这个列表展示了进程间父/子关系。 |
| vmstat | 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上延时的时间（以秒为单位）。例如，“vmstat 5”。 终止输出，按下 Ctrl+C 组合键。 |
| xload | 一个图形界面程序，可以画出系统负载的图形。 |
| tload | 与 xload 程序相似，但是在终端中画出图形。使用 Ctrl+C，来终止输出。 |


